from scapy.all import *
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.layers.http import HTTP, HTTPRequest, HTTPResponse
from scapy.layers.dns import DNS
from scapy.packet import Packet
from scapy.data import TCP_SERVICES, UDP_SERVICES
from dataclasses import dataclass
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import threading
import collections
import re
from firewall_rules import Rule, Action, Protocol
from logger import FirewallLogger
from ipaddress import IPv4Network, IPv4Address

@dataclass
class SecurityAlert:
    """Represents a security alert generated by NIDS"""
    timestamp: datetime
    alert_type: str
    severity: str  # 'low', 'medium', 'high', 'critical'
    source_ip: str
    destination_ip: str
    description: str
    packet_data: dict

class NIDSAnalyzer:
    """Network Intrusion Detection System that integrates with the firewall"""
    
    def __init__(self, packet_handler):
        """Initialize NIDS with firewall's packet handler"""
        self.packet_handler = packet_handler
        self.logger = FirewallLogger()
        
        # Initialize detection components
        self.packet_history = collections.defaultdict(list)  # For rate limiting
        self.connection_tracking = {}  # Track TCP connections
        self.scan_detection = collections.defaultdict(int)  # Port scan detection
        self.alerts = []
        
        # Detection thresholds
        self.RATE_LIMIT_THRESHOLD = 100  # packets per second
        self.PORT_SCAN_THRESHOLD = 15    # unique ports in 5 seconds
        
        # Suspicious patterns for payload analysis
        self.SUSPICIOUS_PATTERNS = [
            re.compile(rb'(?i)(?:union\s+select|drop\s+table|exec\s+sp_|exec\s+xp_)'),  # SQL injection
            re.compile(rb'(?i)(?:<script>|alert\(|onclick=|onerror=)'),  # XSS
            re.compile(rb'(?i)(?:/etc/passwd|/etc/shadow|/proc/self)'),  # Path traversal
        ]
        
        # Start background analysis thread
        self.running = True
        self.analysis_thread = threading.Thread(target=self._background_analysis)
        self.analysis_thread.daemon = True
        self.analysis_thread.start()
        
        # Register with packet handler
        self._register_with_packet_handler()

    def _register_with_packet_handler(self):
        """Extend packet handler's process_packet method to include NIDS analysis"""
        original_process = self.packet_handler.process_packet
        
        def enhanced_process(packet):
            # First, let the firewall process the packet
            allow = original_process(packet)
            
            # If packet is allowed, perform NIDS analysis
            if allow:
                packet_info = self.packet_handler._extract_packet_info(packet)
                if packet_info:
                    alert = self.analyze_packet(packet, packet_info)
                    if alert:
                        self._handle_alert(alert)
            
            return allow
        
        # Replace packet handler's process_packet with enhanced version
        self.packet_handler.process_packet = enhanced_process

    def analyze_packet(self, packet, packet_info: dict) -> Optional[SecurityAlert]:
        """Analyzes a packet for potential security threats"""
        try:
            # Check for rate limiting violations
            if self._check_rate_limiting(packet_info):
                return self._create_alert("Rate Limit Exceeded", "medium", packet_info)

            # Detect port scanning
            if self._detect_port_scan(packet_info):
                return self._create_alert("Port Scan Detected", "high", packet_info)

            # Analyze packet payload for suspicious patterns
            if IP in packet and Raw in packet:
                payload = packet[Raw].load
                for pattern in self.SUSPICIOUS_PATTERNS:
                    if pattern.search(payload):
                        return self._create_alert("Malicious Payload Detected", "critical", packet_info)

            # TCP SYN flood detection
            if TCP in packet and packet[TCP].flags & 0x02:
                if self._detect_syn_flood(packet_info):
                    return self._create_alert("SYN Flood Detected", "high", packet_info)

            # Analyze TCP connection states
            if TCP in packet:
                if self._analyze_tcp_state(packet, packet_info):
                    return self._create_alert("TCP State Violation", "medium", packet_info)

            return None

        except Exception as e:
            self.logger.log_error(f"Error in NIDS analysis: {str(e)}")
            return None

    def _check_rate_limiting(self, packet_info: dict) -> bool:
        """Check if packet rate exceeds threshold"""
        source_ip = packet_info['src_ip']
        current_time = datetime.now()
        
        # Remove old packets from history
        self.packet_history[source_ip] = [
            timestamp for timestamp in self.packet_history[source_ip]
            if current_time - timestamp < timedelta(seconds=1)
        ]
        
        # Add current packet
        self.packet_history[source_ip].append(current_time)
        
        return len(self.packet_history[source_ip]) > self.RATE_LIMIT_THRESHOLD

    def _detect_port_scan(self, packet_info: dict) -> bool:
        """Detect potential port scanning activity"""
        if 'dst_port' not in packet_info:
            return False
            
        source_ip = packet_info['src_ip']
        port = packet_info['dst_port']
        
        # Record port access
        self.scan_detection[source_ip] += 1
        
        return self.scan_detection[source_ip] > self.PORT_SCAN_THRESHOLD

    def _analyze_tcp_state(self, packet, packet_info: dict) -> bool:
        """Analyze TCP connection states for anomalies"""
        if TCP not in packet:
            return False
            
        flags = packet[TCP].flags
        conn_id = f"{packet_info['src_ip']}:{packet_info['dst_ip']}:{packet_info.get('src_port')}"
        
        if conn_id not in self.connection_tracking:
            if flags != 0x02:  # Not a SYN packet
                return True  # Violation - non-SYN packet for new connection
            self.connection_tracking[conn_id] = 'SYN'
        
        return False

    def _detect_syn_flood(self, packet_info: dict) -> bool:
        """Detect potential SYN flood attacks"""
        source_ip = packet_info['src_ip']
        current_time = datetime.now()
        
        syn_count = sum(1 for timestamp in self.packet_history[source_ip]
                       if current_time - timestamp < timedelta(seconds=1))
        
        return syn_count > self.RATE_LIMIT_THRESHOLD

    def _create_alert(self, alert_type: str, severity: str, packet_info: dict) -> SecurityAlert:
        """Create a security alert and trigger response actions"""
        alert = SecurityAlert(
            timestamp=datetime.now(),
            alert_type=alert_type,
            severity=severity,
            source_ip=packet_info['src_ip'],
            destination_ip=packet_info['dst_ip'],
            description=f"{alert_type} detected from {packet_info['src_ip']}",
            packet_data=packet_info
        )
        
        self.alerts.append(alert)
        self.logger.log_warning(
            f"Security Alert: {alert_type} - "
            f"Severity: {severity} - "
            f"Source: {packet_info['src_ip']}"
        )
            
        return alert

    def _handle_alert(self, alert: SecurityAlert):
        """Handle alerts by creating blocking rules for severe threats"""
        if alert.severity in ['high', 'critical']:
            # Create blocking rule
            rule = Rule(
                action=Action.DENY,
                protocol=Protocol.ANY,
                source_ip=alert.source_ip,
                description=f"NIDS Auto-block: {alert.alert_type} from {alert.source_ip}",
                priority=1000  # High priority for security rules
            )
            
            # Add rule to packet handler
            self.packet_handler.add_rule(rule)
            
            self.logger.log_info(
                f"Created blocking rule for {alert.source_ip} "
                f"due to {alert.alert_type}"
            )

    def _background_analysis(self):
        """Background thread for periodic analysis and cleanup"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Clean port scan detection
                self.scan_detection.clear()
                
                # Clean connection tracking older than 5 minutes
                stale_connections = [
                    conn for conn, state in self.connection_tracking.items()
                    if current_time - state.get('timestamp', current_time) > timedelta(minutes=5)
                ]
                for conn in stale_connections:
                    del self.connection_tracking[conn]
                
            except Exception as e:
                self.logger.log_error(f"Error in background analysis: {str(e)}")
                
            time.sleep(60)  # Run every minute

    def stop(self):
        """Stop the NIDS analyzer"""
        self.running = False
        if self.analysis_thread.is_alive():
            self.analysis_thread.join()