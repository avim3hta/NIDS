# nids_analyzer.py

from scapy.all import *
from scapy.layers.inet import IP, TCP, UDP, ICMP
from scapy.layers.http import HTTP, HTTPRequest
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Union
from datetime import datetime, timedelta
import threading
import collections
import re
import sqlite3
from firewall_rules import Rule, Action, Protocol
from logger import FirewallLogger

@dataclass
class SecurityAlert:
    """Represents a security alert generated by NIDS"""
    timestamp: datetime
    alert_type: str
    severity: str
    source_ip: str
    destination_ip: str
    description: str
    packet_data: dict
    alert_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    resolved: bool = False
    resolution_time: Optional[datetime] = None
    resolution_notes: str = ""

class NIDSAnalyzer:
    """
    Network Intrusion Detection System that analyzes traffic for security threats.
    Includes real-time analysis, pattern matching, and anomaly detection.
    """
    
    def __init__(self, interface_name: str):
        self.interface = interface_name
        self.logger = FirewallLogger()
        
        # Initialize detection components
        self.packet_history = collections.defaultdict(list)
        self.connection_tracking = {}
        self.port_tracking = {}
        self.alerts = []
        
        # Detection thresholds
        self.RATE_LIMIT_THRESHOLD = 100
        self.PORT_SCAN_THRESHOLD = 15
        self.SYN_FLOOD_THRESHOLD = 50
        self.BRUTE_FORCE_THRESHOLD = 10
        
        # Initialize databases
        self._init_databases()
        
        # Suspicious patterns
        self.SUSPICIOUS_PATTERNS = [
            re.compile(rb'(?i)(?:union\s+select|drop\s+table|exec\s+sp_)'),
            re.compile(rb'(?i)(?:<script>|alert\(|onclick=)'),
            re.compile(rb'(?i)(?:/etc/passwd|/etc/shadow)'),
            re.compile(rb'(?i)(?:;\s*(?:bash|sh)|\/bin\/(?:bash|sh))'),
            re.compile(rb'(?i)(?:\.\.\/|\.\.\\|~\/|~\\)')
        ]
        
        # Thread management
        self.running = False
        self.analysis_thread = None
        
    def _init_databases(self):
        """Initialize SQLite databases for alert and threat tracking"""
        self.db_conn = sqlite3.connect(':memory:', check_same_thread=False)
        self.db_cursor = self.db_conn.cursor()
        
        # Create alerts table
        self.db_cursor.execute('''
            CREATE TABLE IF NOT EXISTS alerts (
                alert_id TEXT PRIMARY KEY,
                timestamp DATETIME,
                alert_type TEXT,
                severity TEXT,
                source_ip TEXT,
                description TEXT,
                resolved BOOLEAN
            )
        ''')
        
        # Create threat intel table
        self.db_cursor.execute('''
            CREATE TABLE IF NOT EXISTS threat_intel (
                ip_address TEXT PRIMARY KEY,
                threat_score INTEGER,
                last_seen DATETIME,
                attack_types TEXT
            )
        ''')
        self.db_conn.commit()

    def start(self):
        """Start the NIDS analyzer"""
        self.running = True
        self.analysis_thread = threading.Thread(target=self._background_analysis)
        self.analysis_thread.daemon = True
        self.analysis_thread.start()
        self.logger.log_info(f"NIDS Analyzer started on interface {self.interface}")

    def stop(self):
        """Stop the NIDS analyzer"""
        self.running = False
        if self.analysis_thread and self.analysis_thread.is_alive():
            self.analysis_thread.join()
        self.db_conn.close()
        self.logger.log_info("NIDS Analyzer stopped")

    def analyze_packet(self, packet: Packet, packet_info: dict) -> Optional[SecurityAlert]:
        """
        Main packet analysis method that coordinates all detection mechanisms
        """
        try:
            # Basic rate limiting
            if self._check_rate_limiting(packet_info):
                return self._create_alert("Rate Limit Exceeded", "medium", packet_info)

            # Port scan detection
            if self._detect_port_scan(packet_info):
                return self._create_alert("Port Scan Detected", "high", packet_info)

            # Payload analysis
            if packet.haslayer(Raw):
                alert = self._analyze_payload(packet, packet_info)
                if alert:
                    return alert

            # Protocol-specific analysis
            if packet.haslayer(TCP):
                alert = self._analyze_tcp(packet, packet_info)
                if alert:
                    return alert
            elif packet.haslayer(UDP):
                alert = self._analyze_udp(packet, packet_info)
                if alert:
                    return alert

            return None

        except Exception as e:
            self.logger.log_error(f"Error analyzing packet: {str(e)}")
            return None

    def _analyze_payload(self, packet: Packet, packet_info: dict) -> Optional[SecurityAlert]:
        """Analyze packet payload for malicious content"""
        payload = packet[Raw].load
        
        for pattern in self.SUSPICIOUS_PATTERNS:
            if pattern.search(payload):
                return self._create_alert("Malicious Payload", "critical", packet_info)
        
        return None

    def _analyze_tcp(self, packet: Packet, packet_info: dict) -> Optional[SecurityAlert]:
        """Analyze TCP-specific threats"""
        # Check for SYN flood
        if packet[TCP].flags & 0x02 and self._detect_syn_flood(packet_info):
            return self._create_alert("SYN Flood Attack", "high", packet_info)
            
        # Check TCP state violations
        if self._analyze_tcp_state(packet, packet_info):
            return self._create_alert("TCP State Violation", "medium", packet_info)
            
        return None

    def _analyze_udp(self, packet: Packet, packet_info: dict) -> Optional[SecurityAlert]:
        """Analyze UDP-specific threats"""
        # Add UDP-specific threat detection here
        return None

    def _check_rate_limiting(self, packet_info: dict) -> bool:
        """Check if packet rate exceeds threshold"""
        source_ip = packet_info['src_ip']
        current_time = datetime.now()
        
        # Clean old history
        self.packet_history[source_ip] = [
            timestamp for timestamp in self.packet_history[source_ip]
            if current_time - timestamp < timedelta(seconds=1)
        ]
        
        self.packet_history[source_ip].append(current_time)
        
        return len(self.packet_history[source_ip]) > self.RATE_LIMIT_THRESHOLD

    def _detect_port_scan(self, packet_info: dict) -> bool:
        """Detect potential port scanning activity"""
        if 'dst_port' not in packet_info:
            return False
            
        source_ip = packet_info['src_ip']
        current_time = datetime.now()
        
        if source_ip not in self.port_tracking:
            self.port_tracking[source_ip] = {
                'ports': set(),
                'last_reset': current_time
            }
        
        # Reset tracking after 5 seconds
        if current_time - self.port_tracking[source_ip]['last_reset'] > timedelta(seconds=5):
            self.port_tracking[source_ip] = {
                'ports': set(),
                'last_reset': current_time
            }
        
        self.port_tracking[source_ip]['ports'].add(packet_info['dst_port'])
        
        return len(self.port_tracking[source_ip]['ports']) > self.PORT_SCAN_THRESHOLD

    def _detect_syn_flood(self, packet_info: dict) -> bool:
        """Detect SYN flood attacks"""
        source_ip = packet_info['src_ip']
        current_time = datetime.now()
        
        syn_count = sum(1 for timestamp in self.packet_history[source_ip]
                       if current_time - timestamp < timedelta(seconds=1))
                       
        return syn_count > self.SYN_FLOOD_THRESHOLD

    def _create_alert(self, alert_type: str, severity: str, packet_info: dict) -> SecurityAlert:
        """Create and process a security alert"""
        alert = SecurityAlert(
            timestamp=datetime.now(),
            alert_type=alert_type,
            severity=severity,
            source_ip=packet_info['src_ip'],
            destination_ip=packet_info['dst_ip'],
            description=f"{alert_type} detected from {packet_info['src_ip']}",
            packet_data=packet_info
        )
        
        # Store alert
        self.alerts.append(alert)
        self._store_alert_db(alert)
        
        # Log alert
        self.logger.log_warning(
            f"Security Alert: {alert_type} - "
            f"Severity: {severity} - "
            f"Source: {packet_info['src_ip']}"
        )
        
        # Update threat intelligence
        self._update_threat_intel(alert)
        
        return alert

    def _store_alert_db(self, alert: SecurityAlert):
        """Store alert in SQLite database"""
        self.db_cursor.execute('''
            INSERT INTO alerts 
            (alert_id, timestamp, alert_type, severity, source_ip, description, resolved)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            alert.alert_id,
            alert.timestamp,
            alert.alert_type,
            alert.severity,
            alert.source_ip,
            alert.description,
            alert.resolved
        ))
        self.db_conn.commit()

    def _update_threat_intel(self, alert: SecurityAlert):
        """Update threat intelligence database"""
        self.db_cursor.execute('''
            INSERT OR REPLACE INTO threat_intel 
            (ip_address, threat_score, last_seen, attack_types)
            VALUES (?, 
                    COALESCE((SELECT threat_score + ? FROM threat_intel 
                             WHERE ip_address = ?), ?),
                    ?, ?)
        ''', (
            alert.source_ip,
            self._get_severity_score(alert.severity),
            alert.source_ip,
            self._get_severity_score(alert.severity),
            alert.timestamp,
            alert.alert_type
        ))
        self.db_conn.commit()

    def _get_severity_score(self, severity: str) -> int:
        """Convert severity to numerical score"""
        return {
            'low': 1,
            'medium': 5,
            'high': 10,
            'critical': 20
        }.get(severity.lower(), 1)

    def get_stats(self) -> Dict:
        """Get analyzer statistics"""
        return {
            'total_alerts': len(self.alerts),
            'alerts_by_type': collections.Counter(alert.alert_type for alert in self.alerts),
            'alerts_by_severity': collections.Counter(alert.severity for alert in self.alerts),
            'active_connections': len(self.connection_tracking),
            'tracked_ips': len(self.packet_history)
        }

    def _background_analysis(self):
        """Background thread for periodic analysis and cleanup"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Clean old data
                self._cleanup_old_data(current_time)
                
                # Analyze patterns
                self._analyze_patterns()
                
                time.sleep(60)
                
            except Exception as e:
                self.logger.log_error(f"Error in background analysis: {str(e)}")
                time.sleep(60)

    def _cleanup_old_data(self, current_time: datetime):
        """Clean up old tracking data"""
        # Clean packet history
        for ip in list(self.packet_history.keys()):
            self.packet_history[ip] = [
                timestamp for timestamp in self.packet_history[ip]
                if current_time - timestamp < timedelta(hours=1)
            ]
            if not self.packet_history[ip]:
                del self.packet_history[ip]
        
        # Clean port tracking
        for ip in list(self.port_tracking.keys()):
            if current_time - self.port_tracking[ip]['last_reset'] > timedelta(minutes=5):
                del self.port_tracking[ip]
        
        # Clean old alerts from memory (keep last 1000)
        if len(self.alerts) > 1000:
            self.alerts = self.alerts[-1000:]

    def _analyze_patterns(self):
        """Analyze traffic patterns for advanced threat detection"""
        try:
            # Get recent alerts
            self.db_cursor.execute('''
                SELECT source_ip, COUNT(*) as alert_count
                FROM alerts
                WHERE timestamp > datetime('now', '-1 hour')
                GROUP BY source_ip
                HAVING alert_count > ?
            ''', (self.BRUTE_FORCE_THRESHOLD,))
            
            # Process results
            for source_ip, alert_count in self.db_cursor.fetchall():
                self.logger.log_warning(
                    f"Potential brute force attack detected from {source_ip} "
                    f"({alert_count} alerts in last hour)"
                )
                
        except Exception as e:
            self.logger.log_error(f"Error analyzing patterns: {str(e)}")